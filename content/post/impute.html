---
title: Imputación de datos
author: cabrokiller
date: '2018-01-03'
categories:
  - R
tags:
  - r
  - imputacion
slug: imputacion
draft: true
---



<div id="imputacion-de-datos-en-r" class="section level1">
<h1>Imputación de datos en R</h1>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>Está sentado frente al ordenador, preparado para aplicar todo el conocmiento que posee para explotar una base de datos. Pero se encuentra con un problema… Faltan datos. Casos incompletos, escalas sin pasar, <em>dropouts</em>, o que el desgraciado interno asignado a pasar los datos era un poco vago… En ciencias y sobretodo en las ciencias de la salud es común encontrar bases de datos incompletas. Para él análisis de datos usualmente es necesario elegir alguna metodología para lidiar con estos <em>valores ausentes</em> (NA’s).</p>
<p>Una alternativa es <em>eliminar</em> los NA’s. Ya está!, fuera con todos los casos incompletos, pero esto tiene dos proeblmas.
1. A menos número de casos disminuye la potencia del estudio, y esto no es bueno, no?
2. Hay un sesgo de selección si es que la falta de datos tiene relación con alguna de las variables relevantes.</p>
<p>Pues ¿y que diablos hacemos entonces? pues podemos <em>imputar</em> los datos que faltan.</p>
</div>
<div id="explorar-na" class="section level2">
<h2>Explorar NA</h2>
<p>El primer paso como en cualquier trabajo de análisis de datos decente, implica un <em>análisis exploratorio</em> de los NA. En R esto esto se cosigue fácil y de manera gráfica con a librería <code>VIM</code>.</p>
<pre class="r"><code># cargamos las librerías necesarias
pacman::p_load(tidyverse, VIM, lattice, missForest, mice)

set.seed(41)
# creamos un patrón aleatório de NA 
mis_datos &lt;-
   diamonds %&gt;%
   sample_n(500) %&gt;%
   prodNA(noNA = 0.08)

mis_datos %&gt;%
    aggr(col=mdc(1:2), numbers=F, sortVars=T,
         cex.axis=.8, gap=3, only.miss = F, combined = F,
         ylab=c(&quot;Proportion of missingness&quot;,&quot;Missingness Pattern&quot;))</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-1-1.png" width="672" /></p>
<pre><code>## 
##  Variables sorted by number of missings: 
##  Variable Count
##     price 0.094
##   clarity 0.092
##     carat 0.088
##     table 0.086
##       cut 0.082
##     color 0.076
##     depth 0.074
##         x 0.074
##         y 0.072
##         z 0.062</code></pre>
<p>La funcion <code>VIM::aggr</code> permite tener una representación gráfica de los NA y permite ver el patrón que estos presentan. En general se pueden establecer tres tipos de patrones de <a href="https://en.wikipedia.org/wiki/Missing_data#Missing_at_random">valores ausentes:</a>
1. NA totalmente aleatorio (“missing completely at random, o MCAR”) en el que no hay un patrón establecido. El evento por el que hay un valor ausente es independiente de las variables observadas u otros parámetros de interés. Como sospechais es el patrón menos habitual…</p>
<ol start="2" style="list-style-type: decimal">
<li><p>NA aleatorio (“missing at random, o MAR”), en el cual la ausencia de datos no completamente aleatoria, pero en la que se puede dar cuenta de la iformación faltante con los datos existentes, es decir, en la que se puede hacer una estimacion coheerntes de los datos faltantes.</p></li>
<li><p>NA no aleatorio (“missing not at random o MNAR), en el que hay una relacion directa entre el motivo de la ausencia de datos y su propio valor.</p></li>
</ol>
</div>
<div id="metodos-de-imputacion-de-datos" class="section level2">
<h2>Métodos de imputación de datos</h2>
</div>
<div id="tenedencia-central" class="section level2">
<h2>tenedencia central</h2>
<p>Una primera alternbativa, la de <em>toda la vida</em>, es imputar con algún estadístico de tendencia central (media, mediana, moda). Es decir, cambiamos todos los NA por el promedio de los datos que <em>si</em> tenemos. ¿Ventajas? Facil de hacer. ¿Problema? stamos disminyendo artificialmente la variabilidad de la muestra. La implementación en R es realativamente fácil como se muestra a continuación.</p>
<pre class="r"><code>calc_moda &lt;- function(x) {
   z &lt;- table(as.vector(x))
   names(z)[z == max(z)]
}

mis_datos %&gt;%
   mutate(carat = ifelse(is.na(carat), mean(carat, na.rm=T), carat),
          cut = if_else(is.na(cut), calc_moda(cut), &quot;cut&quot;))</code></pre>
<pre><code>## # A tibble: 500 x 10
##    carat cut   color clarity depth table price     x     y     z
##    &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 1.09  cut   G     SI1      62.2  56.0  5022  6.60  6.55  4.09
##  2 0.800 cut   I     &lt;NA&gt;     60.9  60.0    NA  6.01  5.95  3.64
##  3 0.320 cut   D     SI1      62.0  57.0   756  4.40  4.37  2.72
##  4 1.06  cut   &lt;NA&gt;  SI2      61.8  57.0  4270  6.57  6.60  4.07
##  5 0.550 cut   H     &lt;NA&gt;     61.6  55.0  1668  5.30  5.31  3.26
##  6 0.720 cut   D     SI2      60.5  60.0  2429  5.82  5.72  3.49
##  7 0.700 cut   E     &lt;NA&gt;     64.4  58.0  1998  5.58  5.51  3.57
##  8 0.300 cut   G     VVS2     62.1  55.0   665  4.32 NA     2.69
##  9 0.500 cut   E     VS2      62.1  55.0  1554  5.11  5.13  3.18
## 10 0.410 cut   G     SI1      62.7  58.0   923  4.74  4.70  2.96
## # ... with 490 more rows</code></pre>
<p>Otras alternativas comúnmente utilizadas son las de reemplazar los NA’s por algún estadístico de tendencia central (media, mediana o moda para variables categoriales) esto solventa en parte los problemas, pero agregamos muchos casos con la media a una muestra, estamos distinto su variabilidad.</p>
<p>De aquí a que existan diferentes alternativas para lidiar con este problema.</p>
<div id="frecuencia-de-na" class="section level3">
<h3>Frecuencia de NA</h3>
<p>En primer lugar se debe establecer la frecuencia de NA por <em>casos</em> y <em>variables</em> y definir un nivel de tolerancia para la imputación de datos. Si bien no hay (o yo no sé) de un estándar, se suele considerar que para una correcta imputación, el porcentaje de NA debe ser menor de un 10 %.</p>
</div>
<div id="patron-de-na" class="section level3">
<h3>Patrón de NA</h3>
<p>Luego es necesario explorar el patrón de NA y valorar si es que los NA se rigen por un patrón aleatorio (“missing at random” o MAR) o por un patrón no aleatorio (“missing not at random” o MNAR). Una buena aproximación a eso es él examen visual del pistón de NA, que resulta fácil con el paquete VIM.</p>
<p>En general, los diferentes métodos de impresión pueden lidiar con variables MAR. Las variables MINAR conllevan más problemas en cuanto a la imputación, y muchas veces es necesario hacer un análisis de sensibilidad posterior para valorar la imputación.</p>
</div>
<div id="metodo-de-imputacion" class="section level3">
<h3>Método de imputación</h3>
<p>Una vez que hemos establecido la necesidad de imputación, toca seleccionar que metodología utilizaremos. El método en cuestión va a depender en parte de:
- El tipo de variable (numérica, categorial, binaria…)
- El tipo de modelo que aplicaremos (regresión lineal, PCA…)</p>
</div>
</div>
</div>
