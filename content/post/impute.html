---
title: Imputación de datos
author: cabrokiller
date: '2018-01-03'
categories:
  - R
tags:
  - r
  - imputacion
slug: imputacion
draft: false
comments: true
---



<div id="imputacion-de-datos-en-r" class="section level1">
<h1>Imputación de datos en R</h1>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>Está sentado frente al ordenador, preparado para aplicar todo el conocmiento que posee para explotar una base de datos. Pero se encuentra con un problema… Faltan datos. Casos incompletos, escalas sin pasar, <em>dropouts</em>, o que el desgraciado interno asignado a pasar los datos era un poco vago… En ciencias y sobretodo en las ciencias de la salud es común encontrar bases de datos incompletas. Para él análisis de datos usualmente es necesario elegir alguna metodología para lidiar con estos <em>valores ausentes</em> (NA’s).</p>
<p>Una alternativa es <em>eliminar</em> los NA’s. Ya está!, fuera con todos los casos incompletos, pero esto tiene dos proeblmas.
1. A menos número de casos disminuye la potencia del estudio, y esto no es bueno, no?
2. Hay un sesgo de selección si es que la falta de datos tiene relación con alguna de las variables relevantes.</p>
<p>Pues ¿y que diablos hacemos entonces? pues podemos <em>imputar</em> los datos que faltan.</p>
</div>
<div id="explorar-na" class="section level2">
<h2>Explorar NA</h2>
<p>El primer paso como en cualquier trabajo de análisis de datos decente, implica un <em>análisis exploratorio</em> de los NA. En R esto esto se cosigue fácil y de manera gráfica con a librería <code>VIM</code>.</p>
<pre class="r"><code># cargamos las librerías necesarias
pacman::p_load(tidyverse, VIM, lattice, missForest, mice)</code></pre>
<pre class="r"><code>set.seed(41)
# creamos un patrón aleatório de NA 
mis_datos &lt;-
   diamonds %&gt;%
   sample_n(200) %&gt;%
   prodNA(noNA = 0.08)

mis_datos %&gt;%
    aggr(col=mdc(1:2), numbers=F, sortVars=T,
         cex.axis=.8, gap=3, only.miss = F, combined = F,
         ylab=c(&quot;Proportion of missingness&quot;,&quot;Missingness Pattern&quot;))</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-2-1.png" width="672" /></p>
<pre><code>## 
##  Variables sorted by number of missings: 
##  Variable Count
##       cut 0.105
##     table 0.100
##         x 0.095
##         y 0.095
##     depth 0.075
##     price 0.075
##         z 0.075
##     color 0.065
##   clarity 0.060
##     carat 0.055</code></pre>
<p>La funcion <code>VIM::aggr</code> permite tener una representación gráfica de los NA y permite ver el patrón que estos presentan. En general se pueden establecer tres tipos de patrones de <a href="https://en.wikipedia.org/wiki/Missing_data#Missing_at_random">valores ausentes:</a>
1. NA totalmente aleatorio (“missing completely at random, o MCAR”) en el que no hay un patrón establecido. El evento por el que hay un valor ausente es independiente de las variables observadas u otros parámetros de interés. Como sospechais es el patrón menos habitual…</p>
<ol start="2" style="list-style-type: decimal">
<li><p>NA aleatorio (“missing at random, o MAR”), en el cual la ausencia de datos no completamente aleatoria, pero en la que se puede dar cuenta de la iformación faltante con los datos existentes, es decir, en la que se puede hacer una estimacion coheerntes de los datos faltantes.</p></li>
<li><p>NA no aleatorio (“missing not at random o MNAR), en el que hay una relacion directa entre el motivo de la ausencia de datos y su propio valor.</p></li>
</ol>
</div>
<div id="metodos-de-imputacion-de-datos" class="section level2">
<h2>Métodos de imputación de datos</h2>
<div id="tenedencia-central" class="section level3">
<h3>tenedencia central</h3>
<p>Una primera alternbativa, la de <em>toda la vida</em>, es imputar con algún estadístico de tendencia central (media, mediana, moda). Es decir, cambiamos todos los NA por el promedio de los datos que <em>si</em> tenemos. ¿Ventajas? Facil de hacer. ¿Problema? stamos disminyendo artificialmente la variabilidad de la muestra. La implementación en R es realativamente fácil como se muestra a continuación.</p>
<pre class="r"><code>calc_moda &lt;- function(x) {
   z &lt;- table(as.vector(x))
   names(z)[z == max(z)]
}

imp_media &lt;-
   mis_datos %&gt;%
# Media para variables numéricas
   mutate_at(
      vars(carat, depth:z),
      funs(ifelse(is.na(.), mean(., na.rm = T), .))) %&gt;%
# Moda para variables categóricas
   mutate_at(
      vars(cut:clarity),
      funs(as.ordered(ifelse(is.na(.), calc_moda(.), as.character(.)))))</code></pre>
<div id="check" class="section level4">
<h4>check</h4>
<p>Con los datos imputados podemos ver cuanto se ajusta nuestro <em>invento</em> con la base original</p>
<pre class="r"><code>mis_datos$.imp &lt;- &quot;original&quot;
imp_media$.imp &lt;- &quot;imputado&quot;

imp_media %&gt;%
   rbind(mis_datos) %&gt;%
   select(carat, depth, price, z, .imp) %&gt;%
   gather(key, value, -.imp) %&gt;%
   ggplot(aes(x = value, color = .imp))+
   geom_density(size=0.8) +
   facet_wrap(~ key, scales = &quot;free&quot;) +
   scale_color_brewer(type = &quot;qual&quot;, palette = 6, direction = 1) +
   theme_minimal() + labs(title=&quot;Imputación con media aritmética - variables numéricas&quot;)</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code>imp_media %&gt;%
   rbind(mis_datos) %&gt;%
   select(color, cut, .imp) %&gt;%
   gather(key, value, -.imp) %&gt;%
   ggplot(aes(x = value, fill = .imp))+
   geom_bar(alpha = 0.8, position = position_dodge()) +
   facet_wrap(~ key, scales = &quot;free&quot;) +
   scale_fill_brewer(type = &quot;qual&quot;, palette = 6, direction = 1) +
   theme_minimal() + labs(title=&quot;Imputación con moda - variables categóricas&quot;)</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-4-2.png" width="672" /></p>
<p>Es facilmnte apreciable como tqnto en las variables numéricas como en las categóricas, la tendencia central está exagerada y se aleja de la distribución original.</p>
</div>
</div>
<div id="imputacion-multiple" class="section level3">
<h3>Imputación multiple</h3>
<p>una de las metodologias mas utilizadas para la obtencion de una uestra imputada mas <em>correcta</em> es la que utliza tecnicas de imputcoin multiple, es decir imputar mas de una base de datos. Esto permite utlizar las <em>n</em> bases imputadas para hacer <em>n</em> modelos, que posteriormente se poolean (lo siento, no se como diablos se traduce eso…) con la ventaja de que el model final da cuenta de las pequeñas diferencias de las bases imputadas.
LA mayoría de las librería permite calibrar bastante la generacion de las bases, además de la metodología para la imputacion de los valores. Uno de los paquetes mejor documentados es el <a href="http://stefvanbuuren.github.io/mice/">mice</a></p>
<p>El proceso es relativamente facil y esta muy bien docuemntado en las viñetas. El método de imutación por deficnicion es el <em>predictive mean matching</em> para variables numéricas, <em>logistic imputation</em> para categoriales binarias y <em>polytomous regression imputation</em> para categoriales de mas de dos factores.</p>
<pre class="r"><code>pacman::p_load(mice)
imp_mice &lt;- mice(select(mis_datos, -.imp))</code></pre>
<pre><code>## 
##  iter imp variable
##   1   1  carat  cut  color  clarity  depth  table  price  x  y  z
##   1   2  carat  cut  color  clarity  depth  table  price  x  y  z
##   1   3  carat  cut  color  clarity  depth  table  price  x  y  z
##   1   4  carat  cut  color  clarity  depth  table  price  x  y  z
##   1   5  carat  cut  color  clarity  depth  table  price  x  y  z
##   2   1  carat  cut  color  clarity  depth  table  price  x  y  z
##   2   2  carat  cut  color  clarity  depth  table  price  x  y  z
##   2   3  carat  cut  color  clarity  depth  table  price  x  y  z
##   2   4  carat  cut  color  clarity  depth  table  price  x  y  z
##   2   5  carat  cut  color  clarity  depth  table  price  x  y  z
##   3   1  carat  cut  color  clarity  depth  table  price  x  y  z
##   3   2  carat  cut  color  clarity  depth  table  price  x  y  z
##   3   3  carat  cut  color  clarity  depth  table  price  x  y  z
##   3   4  carat  cut  color  clarity  depth  table  price  x  y  z
##   3   5  carat  cut  color  clarity  depth  table  price  x  y  z
##   4   1  carat  cut  color  clarity  depth  table  price  x  y  z
##   4   2  carat  cut  color  clarity  depth  table  price  x  y  z
##   4   3  carat  cut  color  clarity  depth  table  price  x  y  z
##   4   4  carat  cut  color  clarity  depth  table  price  x  y  z
##   4   5  carat  cut  color  clarity  depth  table  price  x  y  z
##   5   1  carat  cut  color  clarity  depth  table  price  x  y  z
##   5   2  carat  cut  color  clarity  depth  table  price  x  y  z
##   5   3  carat  cut  color  clarity  depth  table  price  x  y  z
##   5   4  carat  cut  color  clarity  depth  table  price  x  y  z
##   5   5  carat  cut  color  clarity  depth  table  price  x  y  z</code></pre>
<pre class="r"><code>imp_mice %&gt;%
   complete(action = &quot;long&quot;) %&gt;%
   select(-.id) %&gt;%
   rbind(mis_datos) %&gt;%
   select(carat, depth, price, z, .imp) %&gt;%
   gather(key, value, -.imp) %&gt;%
   ggplot(aes(x = value, color = .imp))+
   geom_density(size = 0.8, alpha = .8) +
   facet_wrap(~ key, scales = &quot;free&quot;) +
   scale_color_brewer(type = &quot;seq&quot;, palette = 8) +
   theme_minimal() + labs(title=&quot;Imputación con media aritmética - variables numéricas&quot;)</code></pre>
<pre><code>## Warning: Removed 56 rows containing non-finite values (stat_density).</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>imp_mice %&gt;%
   complete(action = &quot;long&quot;) %&gt;%
   select(-.id) %&gt;%
   select(color, cut, .imp) %&gt;%
   gather(key, value, -.imp) %&gt;%
   ggplot(aes(x = value, fill = .imp))+
   geom_bar(alpha = 0.8, position = position_dodge()) +
   facet_wrap(~ key, scales = &quot;free&quot;) +
   scale_fill_brewer(type = &quot;seq&quot;, palette =8) +
   theme_minimal() + labs(title=&quot;Imputación con moda - variables categóricas&quot;)</code></pre>
<pre><code>## Warning: attributes are not identical across measure variables;
## they will be dropped</code></pre>
<p><img src="/rmarkdown-libs/figure-html4/unnamed-chunk-5-2.png" width="672" /></p>
<p>Se ajusta mejor no? y eso que no fue necesario tocar los parámetros por definicion y con sólo 5 iteraciones. El paquete <code>mice</code> tiene un montón de funciones para ajustar el modelo de prediccion. Si les interesa esta aproximacion metanse a leer las <a href="https://cran.r-project.org/web/packages/mice/vignettes/resources.html">viñetas</a>, que están super bien explicadas. <code>mice</code> ademas de los modelos poor definicion acepta varios tipos de modelamiento, inluyendo modelos bayesianos, analissi linear discriminante, y modelos de aperndieaje de maquinas mas coplejos como el Random Forest.</p>
<p><code>mice</code> ademas tiene <em>metodos</em> para una serie de modelos de <em>r base</em> como las funiones que permiten utlizar la <em>clase</em> mids que son los objetos de imputqciones multiple que esxupe el <em>r</em></p>
</div>
</div>
<div id="para-pca" class="section level2">
<h2>Para PCA</h2>
<p>Un problema de las imputaciones multiples es que depeneindo del trato que daremos a los datos, puede no haber un método estandarizado para lidiar con ellos. Es el caso del análisis de componentes priniciaples (PCA) donde no está muy bien establecida una metodología para lidiar con los NA y donde no hay un método específico de la libreia <code>mice</code>. Una aproximación util es la de utilizar es la librería <a href="http://factominer.free.fr/missMDA/index.html"><code>missMDA</code></a>, un <em>compañero</em> de la excelente librería para PCA <a href="http://factominer.free.fr/index.html"><code>FactoMineR</code></a>.
<code>missMDA</code> permite la imputación de datos de tal manera de que los valores imputdos no tengan mayor reprecusion en el resultado del PCA utilizando metodos de reduccion del adimensinalidad ( para mas detalles de cómo lo hace, espabilar y mirar la documentación).
En resumen el metodo se puede aplicar asi:
1. se calucal el numero de dimensiones a utilizar para la imputacion con la funcion <code>estim_ncpPCA</code>.
2. se completa la base utilizando el numero de dimensiones calculada con <code>imputePCA</code>.
3. Se puede revisar de manera gráfica la incerteza de la imputación con la función <code>MIPCA</code>.</p>
<p>En el siguente ejemplo cambiaremos la base a una que sea mas apropiada para un posterior PCA. utilizamos la base <code>geno</code> del paquete <code>missMDA</code> que contiene infromacion de genotipos y ambiente de cultivo, con NA’s</p>
<pre class="r"><code>library(missMDA)
data(geno)

nb&lt;- 
    geno %&gt;%
    estim_ncpPCA(ncp.max=10)</code></pre>
<pre><code>## Warning in impute(X, ncp = ncp, scale = scale, method = method, threshold =
## threshold, : Stopped after 1000 iterations</code></pre>
<pre class="r"><code>imp_MDA &lt;-
    geno %&gt;%
    imputePCA(ncp = nb$ncp) %&gt;%
    purrr::pluck(1) %&gt;%
    as.tibble()

check_MDA &lt;- 
    geno %&gt;%
    MIPCA(ncp=nb$ncp, nboot = 100)

plot(check_MDA)</code></pre>
</div>
</div>
